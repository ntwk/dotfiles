#!/bin/bash
#
# dotfiles - manage symlinked dotfiles

_usage() {
    cat <<EOF
Usage: $0 [OPTIONS] CMD

Command for managing dotfiles.

OPTIONS:
  -h    Show this message.
  -d    Set the destination directory.
  -n    Dry run. Don't actually do anything, just show what would be done.

CMD:
  link          Link all files that don't exist in the destination [default].
  unlink        Unlink all files.
  existing      List existing files that are not already linked.
  basedir       Print the base directory of the dotfiles repository.
EOF
}

_basedir() {
    echo ${basedir}
}

_git_ls() {
    git ls-files | grep -v .gitignore | grep -v .gitmodules | grep -v "^README"
}

_existing() {
    while read; do
        declare dstpath=${destination}/${REPLY}
        declare srcpath=$(pwd -L)/${REPLY}
        if [ -e "$dstpath" ] && [ ! "$dstpath" -ef "$srcpath" ]; then
            echo "$dstpath"
        fi
    done < <(_git_ls)
}

_unlink_subdirs() {
    while read; do
        declare subdir=$(dirname ${REPLY})
        cd ${subdir}
        _unlink $(basename ${subdir})
        cd ${basedir}
    done < <(find ${basedir} -mindepth 2 -maxdepth 2 -name .git)
}

_unlink() {
    declare pfx=$1
    while read; do
        declare dstpath=$(echo "${destination}/${pfx}/${REPLY}" | sed s#//*#/#g)
        declare srcpath=$(pwd -L)/${REPLY}
        declare testdir=$(dirname "$dstpath")
        if [ -e "$dstpath" ] && [ "$dstpath" -ef "$srcpath" ]; then
            echo -n "Unlinking ${dstpath}... "
            if ! $dryrun; then
                unlink "${dstpath}"
                echo "done."
            else
                echo "dryrun."
            fi
            while [ -z "$(ls -A "$testdir")" ] && [ ! "$testdir" -ef "$destination" ]; do
                echo -n "Removing directory ${testdir}... "
                if ! $dryrun; then
                    rmdir "${testdir}"
                    echo "done."
                else
                    echo "dryrun."
                fi
                testdir=$(dirname "$testdir")
            done
        fi
    done < <(_git_ls)
}

_link_subdirs() {
    while read; do
        declare subdir=$(dirname ${REPLY})
        cd ${subdir}
        _link $(basename ${subdir})
        cd ${basedir}
    done < <(find ${basedir} -mindepth 2 -maxdepth 2 -name .git)
}

_link() {
    declare pfx=$1
    while read; do
        declare dstpath=$(echo "${destination}/${pfx}/${REPLY}" | sed s#//*#/#g)
        declare srcpath=$(pwd -L)/${REPLY}
        declare dstdir=$(dirname "${dstpath}")
        if [ ! -e "$dstdir" ]; then
            echo -n "Creating directory ${dstdir}... "
            if ! $dryrun; then
                mkdir -p "${dstdir}"
                echo "done."
            else
                echo "dryrun."
            fi
        fi
        if [ ! -e "$dstpath" ]; then
            echo -n "Linking ${dstpath} to ${srcpath}... "
            if ! $dryrun; then
                ln -s "${srcpath}" "${dstpath}"
                echo "done."
            else
                echo "dryrun."
            fi
        elif [ ! -L "$dstpath" ]; then
            echo "${dstpath} already exists and is not a link."
        fi
    done < <(_git_ls)
}

declare destination=${HOME}
declare dryrun=false

while getopts "hnd:" OPTION; do
    case $OPTION in
        h)
            _usage
            exit 0
            ;;
        n)
            dryrun=true
            ;;
        d)
            destination=$(realpath $OPTARG)
            ;;
    esac
done

shift $((OPTIND-1))

cd $(dirname $(readlink "$0" || echo $0))/..
basedir=$(pwd -L)

cmd=$1

case $cmd in
    basedir)
        _basedir
        ;;
    existing)
        _existing
        ;;
    unlink)
        _unlink
        _unlink_subdirs
        ;;
    link)
        _link
        _link_subdirs
        cd ${basedir}
        ;;
    *)
        _usage
        exit 1
        ;;
esac
